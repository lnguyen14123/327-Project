Justin Beup, James Glendinning, Luc Nguyen, Joseph Plank, Aayush Roy, Kira Yen
Oscar Morales Ponce
CECS 327-02 11273
11 November 2025

Operating Systems Support and Peer-to-Peer Systems

Our application is a video game which allows players to connect to servers created by themselves and by other players. This process is run by multiple threads and runs on all nodes. This is responsible for game rendering, movement, collisions and sending messages in chat. Publish-Subscribe chat threads are a set of two threads. One handles sending chat messages while the other handles receiving them. All sets of pub-sub chat threads can run on all nodes. The actual player coordinates being passed are routed through UDP. The chat messages and collisions being routed between remote objects are handled with pub-sub, called directly on another player’s node. This means that all players are in a mesh network in regards to chat and collision objects. Only the players involved in the collision are alerted of a collision, making this system fully P2P.

In our p2p design, all nodes must first join a multicast group, in our code we hard coded this to be “224.1.1.1:10000”. All nodes periodically multicast their ip and port to this address and subsequently listen on this address for other nodes. This allows for fully decentralized peer discovery. There is no need for a central server to maintain a list of players, instead each peer maintains a dictionary of all other peers in the network. Every node maintains a list of peer addresses discovered through multicast. It uses UDP to send its current player position to each peer in that list, ensuring that every client stays synchronized with the others. 

Our high-level design currently consists of 3 different communication systems amongst nodes. Firstly we have our multicast system for peer discovery. This handles the leaving and joining of other peers on the network and allows for decentralized discovery. In this system, each node periodically sends a pulse to all other nodes to notify them of their connection. Next we have our UDP player updates system. This uses UDP and python sockets to update nodes of every other player’s current location. UDP allows for a fast, low overhead method of distributing game data. Finally we use a Publish-Subscribe system to handle collisions between players as well as our chat system. When players collide with one another. The publisher of one player will publish a collision message directly to the other subscribed peer. Similarly, our chat system relies on publishing messages to all subscribers, while nodes are all subscribed to one another, allowing them to send and receive messages.

Our program uses a total of five threads: main, publish, subscribe, peer announcement, and peer discovery. The main thread handles operations per frame of the game, since each loop in the main game’s while loop is one frame. Running networking functions inside the main thread would reduce the performance, since every client would need to handle sending / receiving coordinates before beginning to render the next frame. The publish and subscribe threads handle chat and collisions. Because every player has a reference to every other player’s subscriber object, handling collisions through these objects means the network traffic is only between these two players, reducing the load on other nodes in the network. Finally, the peer announcement and discovery threads are used to add new nodes to the network. Periodically (according to the DISCOVERY_INTERVAL constant in client.py, which is 2 seconds by default), a node will broadcast an announcement message to the multicast group. All other nodes in the group then receive this message, and add these peers to a dictionary if they do not already exist. 

With 5 threads we had to carefully implement locks to prevent race conditions between threads. One example of this occurs when adding a new node to the network. In this case we have a threading.lock()object to protect access to the shared peers data while iterating over it. This ensures that each nodes’ peer data is not modified by another thread while in the process of adding new peers. 

To test our program, we used the test_integration.sh file, which starts 3 instances of the program to test the peer discovery function. Each instance outputs to a separate log file, then test_integration automatically checks those log files to make sure they discovered the other peers on the network. We also used simload.sh to start many instances of the client at once. This isn’t as rigorous of a check as test_instegration.sh, but it allows us to simulate a large number of peers on a network together. Since each player starts in the same position, starting multiple instances sees each player immediately colliding with each other, creating a lot of traffic between peers and letting us observe how the program functions under network load. 
