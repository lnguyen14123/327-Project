Justin Beup, James Glendinning, Luc Nguyen, Joseph Plank, Aayush Roy, Kira Yen  
Oscar Morales Ponce  
CECS 327-02 11273  
1 December 2025  
Time and Global States, Coordination and Agreement, Transactions and Concurrency Control, Distributed Transactions  
Our video game relies on time-dependent events such as players sending and receiving messages to each other during the course of a match. Traditionally, if networks are slow, chat messages may either not arrive in time, or may not be received in proper order among all peers. To solve this problem, we implemented a simple incrementing lamport clock to order the messages. Each message is sent with a timestamp through our chat pub sub. This time stamp is a simple integer variable that is incremented after each chat message is sent. On every local event (sending a chat message), we increment this variable by one. Once we receive a chat with timestamp *T*, we set our current lamport time to max(self.time, *T*) \+ 1, to ensure time always moves forward. Atomicity is ensured since each chat message is always tied to a timestamp. The lamport clock is shared among all peers and is always updated after every chat message, keeping all peers up to date. The data flows from the user to the Publisher, who then sends it to the Subscribers, and finally to other peers. If messages are received out of order, these messages will be sorted in the proper order using their lamport timestamps.  
For the distributed coordination, we implemented the Distributed Mutual Exclusion using a Lamport-style request protocol (mainly inspired by Ricard-Agrawala). We moved forward with this protocol because our game frequently requires shared access with real world objects, but we wanted to avoid any centralized servers. The goal of the protocol is to ensure that at most one node at a time will perform a critical action or state, even though events will be occurring concurrently. In our game, this will be used to coordinate actions such as item removal, item spawning, and world-state updates. These will be triggered by the commit event. When a node needs exclusive access to modify the shared game object, it will first enter the REQUEST phrase, where node increments its Lamport clock. Then it broadcasts a REQUEST(timestamp, node\_id) message, where each of the receiving nodes will update their Lamport clock, then reply with a REPLY message if it isn't requesting access with a smaller timestamp. Next, it enters the WAITING phase, where the requesting node will enter a queue, and it must receive the REPLY messages from the other active nodes before going to the critical section. After that, it enters the critical section, where the node performs the world update command. Finally, it enters the RELEASE phrase, which makes the node broadcast a RELEASE message, allowing other nodes to proceed. The message flow will look something like this: Node A requests access, so it first   
A \-\> all \- REQUEST (12,A). Then the peers reply based on the timestamp comparison, which triggers REPLYs from all nodes where A enters CS, then A will RELEASE(). For the edge case handling, we handle simultaneous requests by having lower Lamport timestamps win, which break ties with the node ID. We handle node failure during REQUEST by having a failure detector mark the node as an inactive object where the quorum shrinks accordingly. We fixed the message delay by enforcing the Lamport timestamps in casual ordering. For the lost RELEASE messages, we made sure nodes use timeout and state reconciliation through a periodic world-state sync. This helps with our game because there is no need for a central coordinator, it is functional in p2p environments, it cleanly integrates with the Lamport clock system, and it  will ensure consistent state-modify actions.   
For our game, we implemented distributed transactions in relation to picking up and using items in game. To pick up an item, a player must be in contact with the item for three seconds. If another player is touching the same item, the item cannot be picked up. We created a Transaction class that recreates this scenario. The Transaction runs begin() when a player touches an item, runs commit() if he or she stays there for three seconds, and no other players touch the item, and runs abort() if either the original player leaves the item, or if another player touches it. Once the item is picked up, the commit() method triggers a pub sub message to be sent to all other peers, in order to inform them that the item should be removed from the world. Our game uses optimistic concurrency, since we donâ€™t apply any locks on the item once the transaction starts. If the conditions for the item pickup are no longer met, we simply abort the transaction. In our example, if two players are trying to pick up an item at the same time, we simply abort the transaction and prevent it from progressing. We also enforce atomicity, since either the item is picked up, or it is not. By the definition of atomicity, there are no half-way actions.